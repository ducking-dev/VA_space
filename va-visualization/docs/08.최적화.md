# 08. 데이터 로딩 속도 최적화 전략서

> **목표**: 54,893개 감정 데이터의 로딩 속도를 5-10초에서 1-2초로 개선  
> **원칙**: SOLID 원칙과 책임 분리 원칙을 기반으로 한 확장 가능한 최적화 아키텍처  
> **날짜**: 2025년 1월 27일  
> **상태**: 🟢 Implemented - Phase 1 완료

---

## 1. 개요

### 1.1 최적화 목표
- ⚡ **로딩 속도**: 5-10초 → 1-2초 (80% 개선)
- 🧠 **메모리 효율성**: 200MB+ → 50MB (75% 개선)
- 🌐 **네트워크 최적화**: 15MB → 4MB (73% 개선)
- 👤 **사용자 경험**: 블로킹 → 점진적 로딩 (90% 개선)

### 1.2 핵심 원칙
- **SOLID 원칙**: 각 클래스는 단일 책임을 가지며 확장 가능
- **책임 분리**: 데이터 로딩, 변환, 캐싱, 렌더링의 명확한 분리
- **성능 우선**: 사용자 경험을 최우선으로 하는 최적화
- **확장성**: 향후 데이터 증가에 대비한 아키텍처

---

## 2. 병목 지점 분석 및 우선순위

### 2.1 병목 지점 우선순위 매트릭스

| 우선순위 | 병목 지점 | 현재 상태 | 영향도 | 해결 난이도 | 예상 개선율 |
|----------|-----------|-----------|--------|-------------|-------------|
| **P0** | JSON 파일 크기 | ~15MB | 🔴 Critical | 🟡 Medium | 80% |
| **P0** | 메모리 사용량 | 200MB+ | 🔴 Critical | 🟡 Medium | 75% |
| **P1** | 네트워크 전송 | 비압축 | 🟡 High | 🟢 Easy | 70% |
| **P1** | 데이터 변환 | 매번 전체 | 🟡 High | 🟡 Medium | 60% |
| **P2** | 캐싱 전략 | 기본 LRU | 🟢 Medium | 🟢 Easy | 40% |
| **P2** | 검색 성능 | O(n) | 🟢 Medium | 🟡 Medium | 50% |

### 2.2 병목 지점 상세 분석

#### **P0: JSON 파일 크기 (Critical)**
- **현재**: 54,893개 객체를 하나의 JSON 파일에 저장
- **문제**: 전체 데이터를 한 번에 로드해야 함
- **해결**: 청크 기반 분할 + 압축

#### **P0: 메모리 사용량 (Critical)**
- **현재**: 모든 데이터를 메모리에 보관
- **문제**: 브라우저 메모리 한계 초과 가능성
- **해결**: 가상화 + 지연 로딩

#### **P1: 네트워크 전송 (High)**
- **현재**: 압축되지 않은 JSON 전송
- **문제**: 대역폭 낭비 및 느린 전송
- **해결**: Gzip 압축 + 스트리밍

---

## 3. SOLID 원칙 기반 최적화 아키텍처

### 3.1 아키텍처 설계 원칙

#### **3.1.1 Single Responsibility Principle (SRP)**
각 클래스는 하나의 명확한 책임만 가짐:

```typescript
// 데이터 로딩만 담당
class DataLoader {
  async loadChunk(chunkId: number): Promise<IEmotionData[]> { }
}

// 데이터 변환만 담당
class DataTransformer {
  transformToRenderable(data: IEmotionData[]): IRenderablePoint[] { }
}

// 캐싱만 담당
class CacheManager {
  get(key: string): any { }
  set(key: string, value: any): void { }
}
```

#### **3.1.2 Open/Closed Principle (OCP)**
기존 코드 수정 없이 새로운 로딩 전략 추가 가능:

```typescript
interface IDataLoadingStrategy {
  loadData(): Promise<IEmotionData[]>;
}

class ChunkedLoadingStrategy implements IDataLoadingStrategy {
  async loadData(): Promise<IEmotionData[]> { }
}

class StreamingLoadingStrategy implements IDataLoadingStrategy {
  async loadData(): Promise<IEmotionData[]> { }
}

class DataLoadingService {
  constructor(private strategy: IDataLoadingStrategy) {}
  
  async loadData(): Promise<IEmotionData[]> {
    return this.strategy.loadData();
  }
}
```

#### **3.1.3 Liskov Substitution Principle (LSP)**
모든 로딩 전략은 동일한 인터페이스로 교체 가능:

```typescript
// 모든 전략이 동일한 인터페이스 구현
const strategies = [
  new ChunkedLoadingStrategy(),
  new StreamingLoadingStrategy(),
  new CachedLoadingStrategy()
];

// 런타임에 전략 교체 가능
strategies.forEach(strategy => {
  const service = new DataLoadingService(strategy);
  service.loadData(); // 동일한 방식으로 호출
});
```

#### **3.1.4 Interface Segregation Principle (ISP)**
클라이언트는 필요한 인터페이스만 의존:

```typescript
// 로딩만 필요한 클라이언트
interface IDataLoader {
  loadData(): Promise<IEmotionData[]>;
}

// 캐싱만 필요한 클라이언트
interface ICacheProvider {
  get(key: string): any;
  set(key: string, value: any): void;
}

// 변환만 필요한 클라이언트
interface IDataTransformer {
  transform(data: IEmotionData[]): IRenderablePoint[];
}
```

#### **3.1.5 Dependency Inversion Principle (DIP)**
고수준 모듈은 저수준 모듈에 의존하지 않음:

```typescript
// 고수준 모듈 (비즈니스 로직)
class EmotionVisualizationService {
  constructor(
    private dataLoader: IDataLoader,
    private transformer: IDataTransformer,
    private cache: ICacheProvider
  ) {}
  
  async renderVisualization(): Promise<IRenderablePoint[]> {
    const data = await this.dataLoader.loadData();
    return this.transformer.transform(data);
  }
}

// 저수준 모듈 (구현체)
class ChunkedDataLoader implements IDataLoader { }
class EmotionDataTransformer implements IDataTransformer { }
class LRUCache implements ICacheProvider { }
```

---

## 4. 책임 분리 원칙 기반 모듈 설계

### 4.1 계층별 책임 분리

#### **4.1.1 Data Layer (데이터 계층)**
```typescript
// lib/data/
├── loaders/           # 데이터 로딩 전담
│   ├── ChunkedLoader.ts
│   ├── StreamingLoader.ts
│   └── CachedLoader.ts
├── transformers/      # 데이터 변환 전담
│   ├── EmotionTransformer.ts
│   └── RenderableTransformer.ts
├── indexers/          # 인덱싱 전담
│   ├── AlphabetIndexer.ts
│   └── SpatialIndexer.ts
└── compressors/       # 압축/해제 전담
    ├── GzipCompressor.ts
    └── BrotliCompressor.ts
```

#### **4.1.2 Service Layer (서비스 계층)**
```typescript
// lib/services/
├── DataLoadingService.ts    # 로딩 오케스트레이션
├── CacheService.ts          # 캐시 관리
├── PerformanceService.ts    # 성능 모니터링
└── VirtualizationService.ts # 가상화 관리
```

#### **4.1.3 Presentation Layer (표현 계층)**
```typescript
// lib/presentation/
├── ProgressiveLoader.ts     # 점진적 로딩 UI
├── LoadingIndicator.ts      # 로딩 상태 표시
└── ErrorBoundary.ts         # 에러 처리
```

### 4.2 모듈 간 의존성 관리

```typescript
// 의존성 주입 컨테이너
class DIContainer {
  private services = new Map();
  
  register<T>(token: string, factory: () => T): void {
    this.services.set(token, factory);
  }
  
  resolve<T>(token: string): T {
    const factory = this.services.get(token);
    return factory();
  }
}

// 서비스 등록
const container = new DIContainer();
container.register('dataLoader', () => new ChunkedDataLoader());
container.register('cache', () => new LRUCache());
container.register('transformer', () => new EmotionTransformer());

// 서비스 사용
const dataLoader = container.resolve<IDataLoader>('dataLoader');
```

---

## 5. 우선순위별 구현 전략

### 5.1 Phase 1: 즉시 적용 (1주차) - P0 병목 해결

#### **5.1.1 청크 기반 데이터 분할**

```typescript
// lib/data/loaders/ChunkedLoader.ts
export class ChunkedDataLoader implements IDataLoader {
  private static readonly CHUNK_SIZE = 1000;
  private static readonly MAX_CONCURRENT = 3;
  
  async loadData(): Promise<IEmotionData[]> {
    const totalChunks = await this.getTotalChunks();
    const allData: IEmotionData[] = [];
    
    // 청크별 병렬 로딩
    for (let i = 0; i < totalChunks; i += ChunkedDataLoader.MAX_CONCURRENT) {
      const chunkPromises = [];
      
      for (let j = 0; j < ChunkedDataLoader.MAX_CONCURRENT && i + j < totalChunks; j++) {
        chunkPromises.push(this.loadChunk(i + j));
      }
      
      const chunks = await Promise.all(chunkPromises);
      chunks.forEach(chunk => allData.push(...chunk));
    }
    
    return allData;
  }
  
  private async loadChunk(chunkId: number): Promise<IEmotionData[]> {
    const response = await fetch(`/api/emotions/chunk/${chunkId}`);
    if (!response.ok) throw new Error(`Failed to load chunk ${chunkId}`);
    return response.json();
  }
  
  private async getTotalChunks(): Promise<number> {
    const response = await fetch('/api/emotions/metadata');
    const metadata = await response.json();
    return Math.ceil(metadata.totalCount / ChunkedDataLoader.CHUNK_SIZE);
  }
}
```

#### **5.1.2 압축 API 구현**

```typescript
// app/api/emotions/chunk/[id]/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const chunkId = parseInt(params.id);
  const compress = request.nextUrl.searchParams.get('compress') === 'true';
  
  try {
    const chunkData = await loadChunkData(chunkId);
    
    if (compress) {
      const compressed = await gzip(JSON.stringify(chunkData));
      return new NextResponse(compressed, {
        headers: {
          'Content-Type': 'application/json',
          'Content-Encoding': 'gzip',
          'Cache-Control': 'public, max-age=3600',
        },
      });
    }
    
    return NextResponse.json(chunkData);
  } catch (error) {
    return NextResponse.json({ error: 'Chunk not found' }, { status: 404 });
  }
}

async function loadChunkData(chunkId: number): Promise<IEmotionData[]> {
  const dataPath = path.join(process.cwd(), 'public', 'data', 'chunks', `chunk_${chunkId}.json`);
  const fileContents = await fs.readFile(dataPath, 'utf8');
  return JSON.parse(fileContents);
}
```

#### **5.1.3 점진적 로딩 UI**

```typescript
// lib/presentation/ProgressiveLoader.tsx
export function ProgressiveLoader() {
  const [progress, setProgress] = useState(0);
  const [loadedData, setLoadedData] = useState<IEmotionData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  
  const dataLoader = useMemo(() => new ChunkedDataLoader(), []);
  
  const loadData = useCallback(async () => {
    setIsLoading(true);
    setProgress(0);
    setLoadedData([]);
    
    try {
      await dataLoader.loadDataProgressively((progress, chunk) => {
        setProgress(progress);
        setLoadedData(prev => [...prev, ...chunk]);
      });
    } catch (error) {
      console.error('Failed to load data:', error);
    } finally {
      setIsLoading(false);
    }
  }, [dataLoader]);
  
  return (
    <div className="progressive-loader">
      <div className="progress-container">
        <div className="progress-bar">
          <div 
            className="progress-fill" 
            style={{ width: `${progress}%` }}
          />
        </div>
        <p className="progress-text">
          {isLoading ? `로딩 중... ${progress.toFixed(1)}%` : '로딩 완료'}
        </p>
      </div>
      
      {loadedData.length > 0 && (
        <ScatterPlot 
          data={loadedData} 
          isPartial={isLoading}
        />
      )}
    </div>
  );
}
```

### 5.2 Phase 2: 고급 최적화 (2주차) - P1 병목 해결

#### **5.2.1 가상화 렌더링**

```typescript
// lib/services/VirtualizationService.ts
export class VirtualizationService implements IVirtualizationService {
  private viewport: IViewport = { x: -1.1, y: -1.1, width: 2.2, height: 2.2 };
  private spatialIndex: Map<string, IEmotionData[]> = new Map();
  
  async getVisibleData(viewport: IViewport): Promise<IEmotionData[]> {
    // 공간 인덱스 기반 빠른 필터링
    const gridCells = this.getGridCells(viewport);
    const visibleData: IEmotionData[] = [];
    
    for (const cell of gridCells) {
      const cellData = this.spatialIndex.get(cell) || [];
      visibleData.push(...cellData);
    }
    
    // 뷰포트 내 데이터만 정확히 필터링
    return visibleData.filter(point => 
      point.valence >= viewport.x &&
      point.valence <= viewport.x + viewport.width &&
      point.arousal >= viewport.y &&
      point.arousal <= viewport.y + viewport.height
    );
  }
  
  private getGridCells(viewport: IViewport): string[] {
    const gridSize = 0.1; // 10x10 그리드
    const cells: string[] = [];
    
    const startX = Math.floor(viewport.x / gridSize);
    const endX = Math.ceil((viewport.x + viewport.width) / gridSize);
    const startY = Math.floor(viewport.y / gridSize);
    const endY = Math.ceil((viewport.y + viewport.height) / gridSize);
    
    for (let x = startX; x <= endX; x++) {
      for (let y = startY; y <= endY; y++) {
        cells.push(`${x},${y}`);
      }
    }
    
    return cells;
  }
}
```

#### **5.2.2 인덱스 기반 검색**

```typescript
// lib/data/indexers/AlphabetIndexer.ts
export class AlphabetIndexer implements IDataIndexer {
  private index: Map<string, number[]> = new Map();
  private data: IEmotionData[] = [];
  
  async buildIndex(data: IEmotionData[]): Promise<void> {
    this.data = data;
    this.index.clear();
    
    // 알파벳별 인덱스 구축
    const alphabet = 'abcdefghijklmnopqrstuvwxyz';
    
    for (const letter of alphabet) {
      const indices: number[] = [];
      data.forEach((emotion, index) => {
        if (emotion.term.toLowerCase().startsWith(letter)) {
          indices.push(index);
        }
      });
      this.index.set(letter, indices);
    }
  }
  
  async searchByPrefix(prefix: string): Promise<IEmotionData[]> {
    const firstLetter = prefix[0].toLowerCase();
    const indices = this.index.get(firstLetter) || [];
    
    return indices
      .map(index => this.data[index])
      .filter(emotion => 
        emotion.term.toLowerCase().startsWith(prefix.toLowerCase())
      );
  }
  
  async searchByRange(
    valenceRange: [number, number],
    arousalRange: [number, number]
  ): Promise<IEmotionData[]> {
    return this.data.filter(emotion => 
      emotion.valence >= valenceRange[0] &&
      emotion.valence <= valenceRange[1] &&
      emotion.arousal >= arousalRange[0] &&
      emotion.arousal <= arousalRange[1]
    );
  }
}
```

### 5.3 Phase 3: 고급 캐싱 (3주차) - P2 병목 해결

#### **5.3.1 다층 캐싱 시스템**

```typescript
// lib/services/CacheService.ts
export class CacheService implements ICacheService {
  private memoryCache: LRUCache<any>;
  private indexedDBCache: IDBWrapper;
  private serviceWorkerCache: ServiceWorkerCache;
  
  constructor() {
    this.memoryCache = new LRUCache(100); // 100개 항목
    this.indexedDBCache = new IDBWrapper('emotion-cache');
    this.serviceWorkerCache = new ServiceWorkerCache();
  }
  
  async get<T>(key: string): Promise<T | null> {
    // 1단계: 메모리 캐시 확인
    let data = this.memoryCache.get(key);
    if (data) return data;
    
    // 2단계: IndexedDB 확인
    data = await this.indexedDBCache.get(key);
    if (data) {
      this.memoryCache.set(key, data); // 메모리 캐시에 복원
      return data;
    }
    
    // 3단계: Service Worker 캐시 확인
    data = await this.serviceWorkerCache.get(key);
    if (data) {
      this.memoryCache.set(key, data);
      await this.indexedDBCache.set(key, data);
      return data;
    }
    
    return null;
  }
  
  async set<T>(key: string, value: T, ttl: number = 3600000): Promise<void> {
    // 모든 캐시 레벨에 저장
    this.memoryCache.set(key, value);
    await this.indexedDBCache.set(key, value, ttl);
    await this.serviceWorkerCache.set(key, value, ttl);
  }
}
```

#### **5.3.2 Web Workers 백그라운드 처리**

```typescript
// public/workers/dataProcessor.worker.ts
self.onmessage = function(e) {
  const { type, data, id } = e.data;
  
  switch (type) {
    case 'PROCESS_EMOTIONS':
      const processed = data.map(emotion => ({
        ...emotion,
        // 복잡한 계산 작업
        normalizedValence: (emotion.valence + 1) / 2,
        normalizedArousal: (emotion.arousal + 1) / 2,
        confidence: calculateConfidence(emotion),
        category: categorizeEmotion(emotion),
      }));
      
      self.postMessage({ type: 'PROCESSED', data: processed, id });
      break;
      
    case 'BUILD_INDEX':
      const index = buildSpatialIndex(data);
      self.postMessage({ type: 'INDEX_BUILT', data: index, id });
      break;
  }
};

function calculateConfidence(emotion: IEmotionData): number {
  // 신뢰도 계산 로직
  return Math.random(); // 임시 구현
}

function categorizeEmotion(emotion: IEmotionData): string {
  // 감정 카테고리 분류 로직
  if (emotion.valence > 0.5 && emotion.arousal > 0.5) return 'joy';
  if (emotion.valence < -0.5 && emotion.arousal > 0.5) return 'anger';
  return 'neutral';
}

function buildSpatialIndex(data: IEmotionData[]): Map<string, IEmotionData[]> {
  const index = new Map();
  const gridSize = 0.1;
  
  data.forEach(emotion => {
    const x = Math.floor(emotion.valence / gridSize);
    const y = Math.floor(emotion.arousal / gridSize);
    const key = `${x},${y}`;
    
    if (!index.has(key)) {
      index.set(key, []);
    }
    index.get(key).push(emotion);
  });
  
  return index;
}
```

---

## 6. 성능 모니터링 및 측정

### 6.1 성능 지표 정의

```typescript
// lib/services/PerformanceService.ts
export class PerformanceService {
  private metrics: Map<string, number[]> = new Map();
  
  startTiming(label: string): () => void {
    const startTime = performance.now();
    
    return () => {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      if (!this.metrics.has(label)) {
        this.metrics.set(label, []);
      }
      this.metrics.get(label)!.push(duration);
      
      console.log(`${label}: ${duration.toFixed(2)}ms`);
    };
  }
  
  getMetrics(): Record<string, { avg: number; min: number; max: number }> {
    const result: Record<string, any> = {};
    
    for (const [label, times] of this.metrics) {
      result[label] = {
        avg: times.reduce((a, b) => a + b, 0) / times.length,
        min: Math.min(...times),
        max: Math.max(...times),
      };
    }
    
    return result;
  }
}
```

### 6.2 Web Vitals 추적

```typescript
// lib/analytics/WebVitals.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

export function trackWebVitals() {
  getCLS(metric => reportMetric('CLS', metric));
  getFID(metric => reportMetric('FID', metric));
  getFCP(metric => reportMetric('FCP', metric));
  getLCP(metric => reportMetric('LCP', metric));
  getTTFB(metric => reportMetric('TTFB', metric));
}

function reportMetric(name: string, metric: any) {
  console.log(`${name}:`, metric.value);
  
  // 외부 분석 서비스로 전송
  if (process.env.NODE_ENV === 'production') {
    // Google Analytics, DataDog 등
  }
}
```

---

## 7. 구현 로드맵

### 7.1 1주차: 기본 최적화
- [x] 청크 기반 데이터 분할 구현
- [x] 압축 API 구현
- [x] 점진적 로딩 UI 구현
- [ ] 기본 성능 측정 도구 설정

### 7.2 2주차: 고급 최적화
- [ ] 가상화 렌더링 구현
- [ ] 인덱스 기반 검색 구현
- [ ] 공간 분할 인덱싱 구현
- [ ] 메모리 사용량 최적화

### 7.3 3주차: 캐싱 및 백그라운드 처리
- [ ] 다층 캐싱 시스템 구현
- [ ] Web Workers 백그라운드 처리
- [ ] Service Worker 캐싱 구현
- [ ] IndexedDB 통합

### 7.4 4주차: 모니터링 및 최적화
- [ ] 성능 모니터링 시스템 구축
- [ ] Web Vitals 추적 구현
- [ ] 성능 벤치마크 테스트
- [ ] 최종 최적화 및 튜닝

---

## 8. 예상 성능 개선 결과

### 8.1 정량적 개선 지표

| 지표 | 현재 | 목표 | 개선율 |
|------|------|------|--------|
| **초기 로딩 시간** | 5-10초 | 1-2초 | 80% ↓ |
| **메모리 사용량** | 200MB+ | 50MB | 75% ↓ |
| **네트워크 전송량** | 15MB | 4MB | 73% ↓ |
| **검색 응답 시간** | 500ms | 50ms | 90% ↓ |
| **렌더링 FPS** | 30fps | 60fps | 100% ↑ |

### 8.2 사용자 경험 개선

- **즉시 반응**: 첫 번째 청크 로딩 후 즉시 시각화 시작
- **점진적 개선**: 데이터가 로딩될수록 시각화 품질 향상
- **부드러운 상호작용**: 가상화로 인한 60fps 유지
- **오프라인 지원**: Service Worker 캐싱으로 오프라인 사용 가능

---

## 9. 결론

SOLID 원칙과 책임 분리 원칙을 적용한 데이터 로딩 최적화 전략을 통해:

1. **확장 가능한 아키텍처**: 새로운 최적화 전략을 쉽게 추가 가능
2. **유지보수성 향상**: 각 모듈의 명확한 책임으로 디버깅 및 수정 용이
3. **성능 최적화**: 80% 이상의 로딩 속도 개선
4. **사용자 경험 개선**: 점진적 로딩으로 즉시 반응하는 UI

이 전략을 단계적으로 구현하면 54,893개 감정 데이터의 효율적인 로딩과 시각화가 가능해집니다.

---

**작성일**: 2025년 1월 27일  
**작성자**: VEATIC 연구팀  
**버전**: v1.0  
**상태**: 🔴 Critical - 즉시 구현 필요

---

## 10. 수정 내역 (2025-10-05)

### Phase 1: P0 병목 해결 (데이터 청킹 및 점진적 로딩) 구현 완료

- **목표**: 초기 데이터 로딩 시 발생하는 심각한 성능 저하 문제 해결
- **상태**: **완료**

#### 주요 변경 사항:

1.  **데이터 청킹 (`scripts/chunk-data.js`)**:
    *   기존의 15MB `merged_vad.json` 파일을 1000개 단위의 청크 55개로 분할하는 스크립트를 추가했습니다.
    *   `public/data/chunks/` 디렉토리에 `chunk_*.json` 형태로 저장됩니다.
    *   데이터셋의 메타 정보 (`totalCount`, `chunkSize`)를 담은 `metadata.json` 파일을 생성하여 API에서 활용하도록 했습니다.

2.  **신규 API 엔드포인트 구현**:
    *   `GET /api/emotions/metadata`: 데이터셋의 전체 크기 및 청크 정보를 제공하는 엔드포인트를 추가했습니다.
    *   `GET /api/emotions/chunk/[id]`: 특정 데이터 청크를 제공하는 동적 라우트를 추가했습니다. `?compress=true` 쿼리 파라미터를 통해 Gzip 압축 전송을 지원하여 네트워크 전송량을 크게 줄였습니다.

3.  **데이터 로더 리팩토링 (`lib/data/loaders/`)**:
    *   SOLID 원칙에 따라 데이터 로딩 책임을 분리하기 위해 `IDataLoader` 인터페이스와 `ChunkedDataLoader` 클래스를 도입했습니다.
    *   `ChunkedDataLoader`는 메타데이터를 먼저 조회한 후, 여러 청크를 병렬로 요청하여 로딩 속도를 극대화합니다.

4.  **`useEmotionData` 훅 개선 (`lib/hooks/data/useEmotionData.ts`)**:
    *   새로운 `ChunkedDataLoader`를 사용하도록 훅을 전면 리팩토링했습니다.
    *   데이터 로딩 진행률(`progress`) 상태를 추가하여 UI에 로딩 상태를 보다 상세히 표시할 수 있도록 했습니다.
    *   데이터를 점진적으로 상태에 추가하여, 청크가 도착하는 즉시 화면에 렌더링할 수 있는 기반을 마련했습니다.

5.  **점진적 로딩 UI (`app/page.tsx`)**:
    *   기존의 단순 스피너를 로딩 진행률을 보여주는 프로그레스 바로 교체했습니다.
    *   `useEmotionData` 훅에서 제공하는 `progress` 값을 사용하여 사용자에게 명확한 피드백을 제공합니다.
    *   데이터가 로딩되는 동안에도 `ScatterPlot` 컴포넌트가 부분적으로 렌더링되도록 `isPartial` 속성을 추가하여 사용자 경험을 개선했습니다.

6.  **코드 정리**:
    *   새로운 아키텍처 도입에 따라 더 이상 사용되지 않는 기존 파일(`lib/services/EmotionDataLoader.ts`, `app/api/emotions/route.ts`)을 삭제하여 코드베이스를 정리했습니다.

#### 기대 효과:

- **초기 로딩 시간 단축**: 전체 데이터를 한 번에 로드하는 대신 작은 청크들을 병렬로 로드하여 사용자가 첫 데이터를 보기까지의 시간이 크게 단축되었습니다.
- **네트워크 효율성 증대**: Gzip 압축을 통해 실제 전송되는 데이터의 크기를 줄였습니다.
- **사용자 경험 향상**: 프로그레스 바를 통해 사용자에게 로딩 상태를 명확히 알려주고, 데이터가 로딩되는 대로 시각화가 갱신되어 시스템이 즉각적으로 반응하는 것처럼 느껴지게 합니다.