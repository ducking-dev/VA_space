# VA-Visualization 프로젝트 유지보수 계획서

## 1. 개요

본 문서는 `va-visualization` 프로젝트의 **빠른 렌더링 속도**와 **안정적인 빌드**를 목표로 하는 성능 최적화 및 유지보수 계획을 정의합니다. 모든 코드는 SOLID 원칙, 성능 최적화 원칙, 그리고 책임 분리 원칙을 기반으로 작성 및 수정되어야 합니다.

### 1.1 핵심 목표
- ⚡ **빠른 렌더링**: 초기 로딩 < 2초, 60fps 애니메이션 유지
- 🛡️ **안정적인 빌드**: 빌드 성공률 100%, 에러 0건
- 📊 **54,893개 감정 데이터**: 실시간 시각화 성능 최적화
- 🔧 **유지보수성**: SOLID 원칙 기반 확장 가능한 구조

## 2. 핵심 원칙

### 2.1. 성능 최적화 원칙 (Performance First)

#### 2.1.1 렌더링 성능 최적화
- **가상화 (Virtualization)**: 54,893개 데이터 포인트의 효율적 렌더링
- **메모이제이션**: React.memo, useMemo, useCallback 적극 활용
- **지연 로딩**: 필요시에만 컴포넌트 및 데이터 로드
- **번들 최적화**: 코드 스플리팅 및 트리 셰이킹

#### 2.1.2 빌드 성능 최적화
- **증분 빌드**: 변경된 파일만 재빌드
- **캐싱 전략**: 빌드 캐시 및 의존성 캐시 활용
- **병렬 처리**: 멀티코어 활용한 빌드 가속화
- **에러 예방**: 컴파일 타임 에러 검출 및 수정

#### 2.1.3 런타임 성능 최적화
- **데이터 구조 최적화**: 효율적인 데이터 접근 패턴
- **알고리즘 최적화**: O(n²) → O(n log n) 복잡도 개선
- **메모리 관리**: 메모리 누수 방지 및 가비지 컬렉션 최적화
- **네트워크 최적화**: API 응답 캐싱 및 압축

### 2.2. SOLID 원칙 적용

- **S (SRP, 단일 책임 원칙):**
  - **정의:** 하나의 클래스(또는 모듈, 함수)는 하나의 책임만 가져야 합니다.
  - **적용:**
    - **Components (`/app/components`):** 순수 UI 렌더링과 사용자 상호작용 처리에만 집중합니다. 데이터 페칭, 상태 관리 로직을 포함하지 않습니다.
    - **Hooks (`/lib/hooks`):** React 상태 관리 및 UI 관련 비즈니스 로직을 처리합니다. (예: `useEmotionData`는 데이터 로딩 상태를 관리)
    - **Services (`/lib/services`):** 외부 API 연동, 데이터 캐싱 등 데이터 입출력 관련 로직을 전담합니다.
    - **Core (`/lib/core`):** 핵심 비즈니스 로직(데이터 변환, 관리)을 담당합니다. (예: `EmotionDataManager`)
    - **Utils (`/lib/utils`):** 특정 도메인에 종속되지 않는 순수 함수(포맷팅, 계산 등)를 제공합니다.

- **O (OCP, 개방-폐쇄 원칙):**
  - **정의:** 기존 코드를 수정하지 않고 기능을 확장할 수 있어야 합니다.
  - **적용:**
    - 새로운 시각화 유형 또는 데이터 소스 추가 시, 기존 `EmotionDataTransformer`나 `EmotionDataLoader`를 수정하는 대신, 새로운 클래스를 만들어 교체할 수 있는 구조를 지향합니다.
    - 컴포넌트의 기능을 확장할 때는 Props를 추가하거나 조합(Composition)하는 방식을 우선적으로 고려합니다.

- **L (LSP, 리스코프 치환 원칙):**
  - **정의:** 하위 타입은 언제나 상위 타입으로 교체할 수 있어야 합니다.
  - **적용:**
    - `/lib/types`에 정의된 타입을 일관성 있게 사용합니다. 예를 들어, `EmotionData` 타입을 사용하는 모든 컴포넌트는 해당 타입의 명세를 만족하는 어떤 데이터 객체와도 동작해야 합니다.

- **I (ISP, 인터페이스 분리 원칙):**
  - **정의:** 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 됩니다.
  - **적용:**
    - 컴포넌트에 Props를 전달할 때, 필요한 데이터만 담은 작은 단위의 `type`이나 `interface`를 정의하여 사용합니다. (예: 전체 `Emotion` 객체 대신 `{ name: string, vad: [number, number] }`만 필요하다면 별도 타입으로 정의)
    - `/lib/types` 내에서 목적에 따라 타입을 명확하게 분리합니다.

- **D (DIP, 의존성 역전 원칙):**
  - **정의:** 상위 모듈은 하위 모듈에 의존해서는 안 되며, 둘 모두 추상화에 의존해야 합니다.
  - **적용:**
    - 컴포넌트(상위)는 `EmotionApiClient`(하위)와 같은 구체적인 데이터 페칭 클래스에 직접 의존하지 않습니다.
    - 대신 `useEmotionData`와 같은 Hook(추상화)에 의존하여, 데이터 소스가 변경되어도 컴포넌트 코드는 영향을 받지 않도록 합니다.

### 2.2. 책임 분리 원칙 (SoC)

프로젝트의 각 디렉토리는 다음과 같은 명확한 책임을 가집니다.

- **`/app`**: 페이지 라우팅 및 레이아웃 정의 (Next.js 규약)
  - **`/app/api`**: 서버 API 엔드포인트
  - **`/app/components`**: 여러 페이지에서 재사용되는 UI 컴포넌트
- **`/lib`**: 애플리케이션의 핵심 로직
  - **`/lib/constants`**: 전역 상수 (색상, API 경로 등)
  - **`/lib/core`**: 도메인 비즈니스 로직 (데이터 처리 및 관리)
  - **`/lib/hooks`**: React 상태 관리 및 커스텀 훅
  - **`/lib/services`**: 외부 서비스 연동 (API 클라이언트, 데이터 로더)
  - **`/lib/types`**: 전역 타입 정의
  - **`/lib/utils`**: 재사용 가능한 순수 유틸리티 함수
- **`/public`**: 정적 에셋 (이미지, 폰트, 샘플 데이터)

---

## 3. 성능 최적화 체크리스트

새로운 기능을 추가하거나 기존 코드를 리팩토링할 때 다음 성능 및 품질 사항을 점검합니다.

### 3.1 렌더링 성능 체크리스트
- [ ] **가상화 적용**: 1000개 이상 데이터 포인트에 가상화 적용했는가?
- [ ] **메모이제이션**: React.memo, useMemo, useCallback을 적절히 사용했는가?
- [ ] **불필요한 리렌더링**: props 변경 시에만 리렌더링되도록 최적화했는가?
- [ ] **번들 크기**: 불필요한 라이브러리 import를 제거했는가?
- [ ] **지연 로딩**: 큰 컴포넌트는 동적 import로 분리했는가?

### 3.2 빌드 안정성 체크리스트
- [ ] **타입 안정성**: TypeScript 에러 0건을 유지하는가?
- [ ] **Import 최적화**: 순환 참조나 불필요한 의존성을 제거했는가?
- [ ] **에러 처리**: 런타임 에러를 방지하는 방어 코드가 있는가?
- [ ] **캐시 전략**: 빌드 캐시를 효율적으로 활용하는가?
- [ ] **의존성 관리**: 최신 버전으로 업데이트하고 보안 취약점을 점검했는가?

### 3.3 코드 품질 체크리스트
- [ ] **책임 분리:** 코드가 올바른 디렉토리(component, hook, service, util 등)에 위치하는가?
- [ ] **단일 책임:** 컴포넌트나 함수가 한 가지 역할에만 집중하는가?
- [ ] **의존성:** 컴포넌트가 구체적인 구현이 아닌 추상화(Hook)에 의존하는가?
- [ ] **타입 정의:** 객체의 형태가 명확하며, `/lib/types`에 잘 정의되어 있는가?
- [ ] **확장성:** 새로운 기능을 추가할 때, 기존 코드를 최소한으로 수정할 수 있는가?

---

## 4. 에러 수정 개발 계획서

### 4.1 프로젝트 현황 분석

#### 4.1.1 완료된 작업
- ✅ **데이터 병합**: Warriner(13,915개) + NRC VAD(55,000개) → 54,893개 통합 감정 어휘
- ✅ **V-A 스케일 정규화**: [-1, 1] 범위로 통일
- ✅ **신뢰도 기반 가중 평균**: 표준편차 기반 지능형 병합 알고리즘
- ✅ **기본 시각화 구조**: Next.js 14 + TypeScript 기반 프로젝트 설정

#### 4.1.2 발견된 주요 에러들
| 에러 유형 | 개수 | 심각도 | 상태 |
|-----------|------|--------|------|
| **Module Not Found** | 3개 | 🔴 Critical | ✅ 해결됨 |
| **타입 불일치** | 4개 | 🔴 Critical | ✅ 해결됨 |
| **Import 경로 오류** | 2개 | 🔴 Critical | ✅ 해결됨 |
| **중복 파일** | 2개 | 🟡 High | ✅ 해결됨 |
| **TypeScript strict 모드** | 2개 | 🟡 High | ✅ 해결됨 |

### 4.2 에러 해결 과정 요약

#### 4.2.1 Phase 1: 모듈 구조 재설계 (완료)
**문제**: Next.js 빌드 시 모듈 해결 실패
**해결책**:
- `next.config.ts` → `next.config.js` 변환
- `tsconfig.json` 경로 매핑 설정
- SOLID 원칙 기반 모듈 구조 재설계

**결과**: ✅ 빌드 성공 (2.7초)

#### 4.2.2 Phase 2: 타입 시스템 정합성 (완료)
**문제**: `IRawEmotionData` 타입과 실제 JSON 데이터 불일치
**해결책**:
- 타입 정의를 실제 데이터 구조에 맞게 수정
- `valence_mean` → `valence`, `arousal_mean` → `arousal`
- TypeScript strict 모드 대응

**결과**: ✅ 타입 에러 0건

#### 4.2.3 Phase 3: Import 경로 정리 (완료)
**문제**: 잘못된 import 경로로 인한 컴파일 실패
**해결책**:
- `@/lib/hooks/interaction` → `@/lib/hooks` 통합
- 중복 export 제거
- 파일 구조 단순화

**결과**: ✅ 모든 import 정상 작동

#### 4.2.4 Phase 4: 중복 파일 제거 (완료)
**문제**: 동일한 기능의 파일이 여러 위치에 존재
**해결책**:
- `lib/hooks/useEmotionData.ts` 삭제 (잘못된 import)
- `lib/hooks/useVirtualization.ts` 삭제 (중복)
- 올바른 파일만 유지

**결과**: ✅ 모듈 충돌 해결

#### 4.2.5 Phase 5: TypeScript 엄격 모드 대응 (완료)
**문제**: strict null checks 및 const assertion 이슈
**해결책**:
- `DataCache.ts`: undefined 체크 추가
- `color.ts`: 명시적 string 타입 지정
- 타입 가드 및 안전한 타입 처리

**결과**: ✅ TypeScript 컴파일 성공

### 4.3 현재 시스템 상태

#### 4.3.1 빌드 성능 지표
```bash
npm run build
# ✅ Exit code: 0
# ✅ Compiled successfully in 2.7s
# ✅ Linting and checking validity of types: 통과
# ✅ Generating static pages (5/5): 완료
```

#### 4.3.2 성능 및 품질 지표
| 지표 | 목표 | 현재 | 상태 |
|------|------|------|------|
| **빌드 시간** | < 3초 | 2.7초 | ✅ |
| **TypeScript 에러** | 0건 | 0건 | ✅ |
| **빌드 성공률** | 100% | 100% | ✅ |
| **초기 로딩** | < 2초 | 측정 필요 | 🔄 |
| **애니메이션 FPS** | 60fps | 측정 필요 | 🔄 |
| **번들 크기** | < 1MB | 측정 필요 | 🔄 |
| **메모리 사용량** | < 100MB | 측정 필요 | 🔄 |

### 4.4 성능 최적화 전략

#### 4.4.1 렌더링 성능 최적화
```typescript
// 가상화 구현 예시
const VirtualizedScatterPlot = React.memo(({ emotions }) => {
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 1000 });
  
  const visibleEmotions = useMemo(() => 
    emotions.slice(visibleRange.start, visibleRange.end),
    [emotions, visibleRange]
  );
  
  return (
    <div onScroll={handleScroll}>
      {visibleEmotions.map(emotion => (
        <EmotionPoint key={emotion.term} emotion={emotion} />
      ))}
    </div>
  );
});

// 메모이제이션 최적화
const EmotionPoint = React.memo(({ emotion }) => {
  const color = useMemo(() => 
    getColorByConfidence(emotion.confidence), 
    [emotion.confidence]
  );
  
  return <circle fill={color} />;
});
```

#### 4.4.2 빌드 성능 최적화
```bash
# 성능 측정 및 최적화 스크립트
npm run analyze       # 번들 분석
npm run lighthouse    # 성능 측정
npm run type-check    # TypeScript 타입 검증
npm run lint         # ESLint 코드 품질 검사
npm run build        # Next.js 빌드 검증
npm run test         # 단위 테스트 실행
```

#### 4.4.3 자동화된 성능 모니터링
- **Web Vitals 추적**: LCP, FID, CLS 실시간 모니터링
- **번들 분석**: webpack-bundle-analyzer로 크기 최적화
- **메모리 프로파일링**: 메모리 누수 탐지 및 해결
- **성능 예산**: 번들 크기 및 로딩 시간 제한 설정

#### 4.4.4 코드 품질 관리
- **ESLint 규칙**: strict 모드 대응 규칙 적용
- **Prettier 설정**: 일관된 코드 포맷팅
- **Husky hooks**: 커밋 전 자동 검증
- **CI/CD 파이프라인**: 자동 빌드, 테스트, 성능 측정

### 4.5 지속적 모니터링 계획

#### 4.5.1 일일 성능 모니터링
- [ ] **빌드 시간**: 3초 이하 유지 확인
- [ ] **TypeScript 에러**: 0건 유지 확인
- [ ] **번들 크기**: 1MB 이하 유지 확인
- [ ] **메모리 사용량**: 100MB 이하 유지 확인
- [ ] **렌더링 성능**: 60fps 유지 확인

#### 4.5.2 주간 점검 항목
- [ ] **성능 지표 추적**: Web Vitals 측정 및 분석
- [ ] **가상화 효율성**: 54,893개 데이터 포인트 렌더링 최적화
- [ ] **메모이제이션 효과**: React.memo, useMemo 사용률 검토
- [ ] **번들 분석**: 불필요한 의존성 제거
- [ ] **캐시 효율성**: 빌드 캐시 및 런타임 캐시 최적화

#### 4.5.3 월간 리뷰 항목
- [ ] **성능 벤치마크**: 이전 대비 성능 개선도 측정
- [ ] **코드 복잡도**: 알고리즘 복잡도 분석 및 최적화
- [ ] **메모리 프로파일링**: 메모리 누수 탐지 및 해결
- [ ] **의존성 업데이트**: 성능 개선이 있는 라이브러리 업데이트
- [ ] **보안 취약점**: 성능에 영향을 주는 보안 이슈 해결

### 4.6 에러 대응 프로세스

#### 4.6.1 에러 발생 시 대응 절차
1. **즉시 대응** (1시간 내)
   - 에러 로그 수집 및 분석
   - 임시 해결책 적용 (핫픽스)
   - 서비스 안정성 확보

2. **근본 원인 분석** (1일 내)
   - 에러 발생 원인 추적
   - 재발 방지 대책 수립
   - 코드 개선 방안 도출

3. **장기 개선** (1주 내)
   - 시스템 아키텍처 개선
   - 모니터링 시스템 강화
   - 개발 프로세스 개선

#### 4.6.2 에러 분류 및 우선순위
| 우선순위 | 에러 유형 | 대응 시간 | 담당자 |
|----------|-----------|-----------|--------|
| **P0** | 서비스 중단 | 즉시 | 전체 팀 |
| **P1** | 핵심 기능 장애 | 4시간 | 개발팀 |
| **P2** | 부가 기능 장애 | 1일 | 담당 개발자 |
| **P3** | 개선 사항 | 1주 | 계획 수립 |

### 4.7 성능 최적화 로드맵

#### 4.7.1 단기 최적화 (1주 내)
1. **가상화 구현**: 54,893개 데이터 포인트 가상화 적용
2. **메모이제이션**: React.memo, useMemo, useCallback 전면 적용
3. **번들 분석**: webpack-bundle-analyzer로 크기 최적화
4. **성능 측정**: Lighthouse로 현재 성능 지표 측정

#### 4.7.2 중기 최적화 (1개월 내)
1. **알고리즘 최적화**: O(n²) → O(n log n) 복잡도 개선
2. **메모리 최적화**: 메모리 누수 방지 및 가비지 컬렉션 최적화
3. **캐싱 전략**: API 응답 캐싱 및 빌드 캐시 최적화
4. **코드 스플리팅**: 동적 import로 번들 크기 분할

#### 4.7.3 장기 최적화 (3개월 내)
1. **WebAssembly**: 계산 집약적 작업을 WASM으로 이전
2. **Service Worker**: 오프라인 캐싱 및 백그라운드 동기화
3. **CDN 최적화**: 정적 자원의 글로벌 배포 최적화
4. **실시간 모니터링**: 성능 지표 실시간 추적 시스템

### 4.8 성능 벤치마크 목표

#### 4.8.1 렌더링 성능 목표
| 지표 | 현재 | 목표 | 달성 기한 |
|------|------|------|-----------|
| **초기 로딩** | 측정 필요 | < 2초 | 2주 |
| **애니메이션 FPS** | 측정 필요 | 60fps | 1주 |
| **메모리 사용량** | 측정 필요 | < 100MB | 1주 |
| **번들 크기** | 측정 필요 | < 1MB | 1주 |

#### 4.8.2 빌드 성능 목표
| 지표 | 현재 | 목표 | 달성 기한 |
|------|------|------|-----------|
| **빌드 시간** | 2.7초 | < 2초 | 1주 |
| **빌드 성공률** | 100% | 100% | 유지 |
| **TypeScript 에러** | 0건 | 0건 | 유지 |
| **Hot Reload** | 측정 필요 | < 500ms | 2주 |

---

## 5. 성능 최적화 구현 가이드

### 5.1 가상화 구현 예시

#### 5.1.1 VirtualizedScatterPlot 컴포넌트
```typescript
import React, { useState, useMemo, useCallback } from 'react';

interface VirtualizedScatterPlotProps {
  emotions: EmotionData[];
  width: number;
  height: number;
  itemHeight: number;
}

export const VirtualizedScatterPlot = React.memo<VirtualizedScatterPlotProps>(({
  emotions,
  width,
  height,
  itemHeight
}) => {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleRange = useMemo(() => {
    const start = Math.floor(scrollTop / itemHeight);
    const end = Math.min(start + Math.ceil(height / itemHeight), emotions.length);
    return { start, end };
  }, [scrollTop, itemHeight, height, emotions.length]);
  
  const visibleEmotions = useMemo(() => 
    emotions.slice(visibleRange.start, visibleRange.end),
    [emotions, visibleRange]
  );
  
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  }, []);
  
  return (
    <div 
      style={{ width, height, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: emotions.length * itemHeight, position: 'relative' }}>
        {visibleEmotions.map((emotion, index) => (
          <EmotionPoint
            key={emotion.term}
            emotion={emotion}
            index={visibleRange.start + index}
            itemHeight={itemHeight}
          />
        ))}
      </div>
    </div>
  );
});
```

#### 5.1.2 메모이제이션 최적화
```typescript
const EmotionPoint = React.memo<{
  emotion: EmotionData;
  index: number;
  itemHeight: number;
}>(({ emotion, index, itemHeight }) => {
  const color = useMemo(() => 
    getColorByConfidence(emotion.confidence), 
    [emotion.confidence]
  );
  
  const position = useMemo(() => ({
    x: emotion.valence * 400 + 400,
    y: emotion.arousal * 400 + 400
  }), [emotion.valence, emotion.arousal]);
  
  return (
    <circle
      cx={position.x}
      cy={position.y}
      r={3}
      fill={color}
      style={{ position: 'absolute', top: index * itemHeight }}
    />
  );
});
```

### 5.2 성능 측정 도구 설정

#### 5.2.1 package.json 스크립트 추가
```json
{
  "scripts": {
    "analyze": "cross-env ANALYZE=true next build",
    "lighthouse": "lighthouse http://localhost:3000 --output=html --output-path=./lighthouse-report.html",
    "perf": "npm run build && npm run lighthouse",
    "type-check": "tsc --noEmit",
    "lint": "next lint",
    "test": "jest"
  }
}
```

#### 5.2.2 Web Vitals 측정
```typescript
// lib/analytics.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

export function reportWebVitals(metric: any) {
  console.log(metric);
  
  // 성능 지표를 외부 서비스로 전송
  if (process.env.NODE_ENV === 'production') {
    // Google Analytics, DataDog 등으로 전송
  }
}

// app/layout.tsx
export function reportWebVitals(metric: any) {
  reportWebVitals(metric);
}
```

### 5.3 빌드 최적화 설정

#### 5.3.1 next.config.js 최적화
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  // 성능 최적화
  compress: true,
  swcMinify: true,
  
  // 번들 분석
  webpack: (config, { isServer }) => {
    if (process.env.ANALYZE === 'true') {
      const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          openAnalyzer: false,
        })
      );
    }
    
    // 성능 최적화
    config.optimization.splitChunks = {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    };
    
    return config;
  },
  
  // 이미지 최적화
  images: {
    formats: ['image/avif', 'image/webp'],
    minimumCacheTTL: 60,
  },
  
  // 실험적 기능
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['d3', 'framer-motion'],
  },
};

module.exports = nextConfig;
```

---

**작성일**: 2025년 1월 27일  
**작성자**: VEATIC 연구팀  
**버전**: v2.0  
**상태**: ✅ 완료 - 성능 최적화 중심의 유지보수 체계 구축
