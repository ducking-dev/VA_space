# V-A 평면 시각화 구현 계획서

> **EasyNext 기반 인터랙티브 V-A 2차원 감정 공간 시각화**

---

## 📋 프로젝트 개요

### 목표

- **V-A 2차원 평면**에 54,893개 감정 어휘 시각화
- **마우스 hover** 시 해당 점의 감정 단어 정보 표시
- **가벼운 애니메이션**과 **빠른 로딩** 최적화
- **EasyNext** 프레임워크 활용한 현대적 웹 인터페이스

### 핵심 요구사항

- ✅ **V-A 2차원만** 시각화 (Dominance 제외)
- ✅ **마우스 hover** 시 단어 정보 표시
- ✅ **가벼운 애니메이션** 효과
- ✅ **빠른 로딩** 및 **반응형** 디자인
- ✅ **EasyNext** 기반 구현

---

## 🎨 시각화 설계

### 1. 기본 레이아웃

#### 1.1 V-A 평면 좌표계

```text
Y축 (Arousal): +1.0 (High Arousal)
                ↑
                |
-1.0 (Low V) ←--+--> +1.0 (High V)  X축 (Valence)
                |
                ↓
Y축 (Arousal): -1.0 (Low Arousal)
```

#### 1.2 감정 영역 분할

- **1사분면** (V+, A+): Joy, Excitement, Surprise
- **2사분면** (V-, A+): Anger, Fear, Disgust  
- **3사분면** (V-, A-): Sadness, Boredom, Depression
- **4사분면** (V+, A-): Calm, Serenity, Contentment

### 2. 시각화 구성요소

#### 2.1 핵심 요소

1. **산점도**: 54,893개 감정 어휘의 V-A 좌표
2. **감정 프로토타입**: 8개 기본 감정 중심점
3. **밀도 히트맵**: 감정 영역별 단어 분포
4. **신뢰 타원**: 불확실성 표현 (선택적)
5. **인터랙티브 툴팁**: 마우스 hover 시 단어 정보

#### 2.2 색상 스키마 (파스텔 톤)

```css
/* 감정 영역별 파스텔 색상 */
.quadrant-1 { background: linear-gradient(45deg, #FFF2CC, #FFE6B3); } /* Joy - 따뜻한 노랑 */
.quadrant-2 { background: linear-gradient(45deg, #FFE6E6, #FFB3B3); } /* Anger - 부드러운 빨강 */
.quadrant-3 { background: linear-gradient(45deg, #E6F3FF, #B3D9FF); } /* Sadness - 차분한 파랑 */
.quadrant-4 { background: linear-gradient(45deg, #E6FFE6, #B3FFB3); } /* Calm - 상쾌한 초록 */

/* 신뢰도별 점 색상 (파스텔 톤) */
.high-confidence { color: #7CB342; }    /* 신뢰도 ≥ 0.8 - 파스텔 그린 */
.medium-confidence { color: #FF8A65; }  /* 신뢰도 0.7-0.8 - 파스텔 오렌지 */
.low-confidence { color: #E57373; }     /* 신뢰도 < 0.7 - 파스텔 레드 */
```

---

## 🛠️ 기술 스택

### 3. EasyNext 기반 구현

#### 3.1 프론트엔드 스택

```typescript
// Next.js 14 + TypeScript
"next": "^14.0.0",
"react": "^18.0.0",
"typescript": "^5.0.0",

// 시각화 라이브러리
"d3": "^7.8.0",           // 핵심 시각화 엔진
"d3-scale": "^4.0.0",     // 스케일링
"d3-selection": "^3.0.0", // DOM 조작
"d3-zoom": "^3.0.0",      // 줌/팬 기능

// 스타일링
"tailwindcss": "^3.3.0",  // 유틸리티 CSS
"framer-motion": "^10.0.0", // 애니메이션
"lucide-react": "^0.290.0", // 아이콘
```

#### 3.2 백엔드 API

```typescript
// API Routes (Next.js)
"@/app/api/emotions/route.ts"     // 감정 데이터 API
"@/app/api/search/route.ts"       // 단어 검색 API
"@/app/api/statistics/route.ts"   // 통계 정보 API
```

### 4. 성능 최적화

#### 4.1 데이터 최적화

```typescript
// 가상화된 렌더링 (54,893개 점 최적화)
const VirtualizedScatterPlot = () => {
  const [visiblePoints, setVisiblePoints] = useState<EmotionPoint[]>([]);
  const [viewport, setViewport] = useState({ x: 0, y: 0, width: 800, height: 600 });
  
  // 뷰포트 내 점만 렌더링
  const updateVisiblePoints = useCallback(() => {
    const filtered = allPoints.filter(point => 
      isPointInViewport(point, viewport)
    );
    setVisiblePoints(filtered);
  }, [viewport]);
};
```

#### 4.2 애니메이션 최적화

```typescript
// Framer Motion 최적화
const AnimatedPoint = ({ point }: { point: EmotionPoint }) => {
  return (
    <motion.circle
      initial={{ scale: 0, opacity: 0 }}
      animate={{ scale: 1, opacity: 0.7 }}
      transition={{ 
        duration: 0.3,
        ease: "easeOut",
        delay: Math.random() * 0.5 // 스태거드 애니메이션
      }}
      whileHover={{ 
        scale: 1.5, 
        opacity: 1,
        transition: { duration: 0.2 }
      }}
    />
  );
};
```

---

## 📁 프로젝트 구조

### 5. 디렉토리 구조

```bash
VA_space/
├─ app/                          # Next.js 14 App Router
│  ├─ page.tsx                   # 메인 V-A 시각화 페이지
│  ├─ api/
│  │  ├─ emotions/route.ts       # 감정 데이터 API
│  │  ├─ search/route.ts         # 검색 API
│  │  └─ statistics/route.ts     # 통계 API
│  └─ components/
│     ├─ VA_Plane.tsx            # 메인 V-A 평면 컴포넌트
│     ├─ ScatterPlot.tsx         # 산점도 컴포넌트
│     ├─ EmotionTooltip.tsx      # 툴팁 컴포넌트
│     ├─ EmotionPrototypes.tsx   # 감정 프로토타입
│     ├─ DensityHeatmap.tsx      # 밀도 히트맵
│     ├─ SearchBar.tsx           # 검색 바
│     └─ StatisticsPanel.tsx     # 통계 패널
├─ lib/
│  ├─ data/
│  │  ├─ emotions.ts             # 감정 데이터 로더
│  │  └─ prototypes.ts           # 감정 프로토타입 정의
│  ├─ utils/
│  │  ├─ visualization.ts        # 시각화 유틸리티
│  │  ├─ color.ts                # 색상 유틸리티
│  │  └─ performance.ts          # 성능 최적화
│  └─ types/
│     └─ emotion.ts              # TypeScript 타입 정의
├─ public/
│  ├─ data/
│  │  └─ merged_vad.json         # 전처리된 감정 데이터
│  └─ assets/
│     └─ icons/                  # 아이콘 리소스
└─ styles/
   └─ globals.css                # 글로벌 스타일
```

---

## 🎯 핵심 컴포넌트 구현

### 6. 메인 V-A 평면 컴포넌트

#### 6.1 VA_Plane.tsx

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { motion } from 'framer-motion';
import { ScatterPlot } from './ScatterPlot';
import { EmotionTooltip } from './EmotionTooltip';
import { EmotionPrototypes } from './EmotionPrototypes';
import { DensityHeatmap } from './DensityHeatmap';
import { SearchBar } from './SearchBar';
import { StatisticsPanel } from './StatisticsPanel';

interface EmotionPoint {
  term: string;
  valence: number;
  arousal: number;
  confidence: number;
  merge_strategy: 'both_weighted' | 'warriner_only' | 'nrc_only';
  is_multiword: boolean;
}

export default function VA_Plane() {
  const [emotions, setEmotions] = useState<EmotionPoint[]>([]);
  const [hoveredPoint, setHoveredPoint] = useState<EmotionPoint | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [showDensity, setShowDensity] = useState(false);
  const [showPrototypes, setShowPrototypes] = useState(true);

  // 데이터 로딩
  useEffect(() => {
    const loadEmotions = async () => {
      const response = await fetch('/api/emotions');
      const data = await response.json();
      setEmotions(data);
    };
    loadEmotions();
  }, []);

  // 검색 필터링
  const filteredEmotions = emotions.filter(emotion =>
    emotion.term.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* 헤더 */}
      <header className="bg-white shadow-sm border-b">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <h1 className="text-3xl font-bold text-gray-900">
            V-A 감정 공간 시각화
          </h1>
          <p className="text-gray-600 mt-2">
            54,893개 감정 어휘의 Valence-Arousal 2차원 공간
          </p>
        </div>
      </header>

      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          {/* 메인 시각화 영역 */}
          <div className="lg:col-span-3">
            <div className="bg-white rounded-lg shadow-lg p-6">
              {/* 컨트롤 패널 */}
              <div className="flex flex-wrap gap-4 mb-6">
                <SearchBar 
                  value={searchTerm}
                  onChange={setSearchTerm}
                />
                <button
                  onClick={() => setShowDensity(!showDensity)}
                  className={`px-4 py-2 rounded-lg transition-colors ${
                    showDensity 
                      ? 'bg-blue-500 text-white' 
                      : 'bg-gray-200 text-gray-700'
                  }`}
                >
                  밀도 히트맵
                </button>
                <button
                  onClick={() => setShowPrototypes(!showPrototypes)}
                  className={`px-4 py-2 rounded-lg transition-colors ${
                    showPrototypes 
                      ? 'bg-green-500 text-white' 
                      : 'bg-gray-200 text-gray-700'
                  }`}
                >
                  감정 프로토타입
                </button>
              </div>

              {/* V-A 평면 */}
              <div className="relative">
                <svg
                  width="100%"
                  height="600"
                  viewBox="-1.1 -1.1 2.2 2.2"
                  className="border border-gray-300 rounded-lg"
                >
                  {/* 격자 배경 */}
                  <defs>
                    <pattern id="grid" width="0.1" height="0.1" patternUnits="userSpaceOnUse">
                      <path d="M 0.1 0 L 0 0 0 0.1" fill="none" stroke="#e5e7eb" strokeWidth="0.5"/>
                    </pattern>
                  </defs>
                  <rect width="2.2" height="2.2" fill="url(#grid)" />

                  {/* 축 라벨 */}
                  <text x="0" y="-1.05" textAnchor="middle" className="text-sm font-medium fill-gray-600">
                    Valence (Pleasure-Displeasure)
                  </text>
                  <text x="-1.05" y="0" textAnchor="middle" className="text-sm font-medium fill-gray-600" transform="rotate(-90, -1.05, 0)">
                    Arousal (Activation-Deactivation)
                  </text>

                  {/* 밀도 히트맵 */}
                  {showDensity && (
                    <DensityHeatmap emotions={filteredEmotions} />
                  )}

                  {/* 산점도 */}
                  <ScatterPlot
                    emotions={filteredEmotions}
                    onHover={setHoveredPoint}
                  />

                  {/* 감정 프로토타입 */}
                  {showPrototypes && (
                    <EmotionPrototypes />
                  )}
                </svg>

                {/* 툴팁 */}
                {hoveredPoint && (
                  <EmotionTooltip 
                    point={hoveredPoint}
                    position={{ x: 0, y: 0 }} // 마우스 위치로 업데이트
                  />
                )}
              </div>
            </div>
          </div>

          {/* 사이드바 통계 */}
          <div className="lg:col-span-1">
            <StatisticsPanel 
              emotions={emotions}
              filteredEmotions={filteredEmotions}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 7. 산점도 컴포넌트

#### 7.1 ScatterPlot.tsx

```typescript
'use client';

import { motion } from 'framer-motion';
import { EmotionPoint } from '@/lib/types/emotion';

interface ScatterPlotProps {
  emotions: EmotionPoint[];
  onHover: (point: EmotionPoint | null) => void;
}

export function ScatterPlot({ emotions, onHover }: ScatterPlotProps) {
  const getPointColor = (confidence: number) => {
    if (confidence >= 0.8) return '#7CB342'; // High confidence - 파스텔 그린
    if (confidence >= 0.7) return '#FF8A65'; // Medium confidence - 파스텔 오렌지
    return '#E57373'; // Low confidence - 파스텔 레드
  };

  const getPointSize = (isMultiword: boolean) => {
    return isMultiword ? 4 : 3;
  };

  return (
    <g>
      {emotions.map((emotion, index) => (
        <motion.circle
          key={`${emotion.term}-${index}`}
          cx={emotion.valence}
          cy={emotion.arousal}
          r={getPointSize(emotion.is_multiword)}
          fill={getPointColor(emotion.confidence)}
          opacity={0.7}
          initial={{ scale: 0, opacity: 0 }}
          animate={{ scale: 1, opacity: 0.7 }}
          transition={{ 
            duration: 0.3,
            ease: "easeOut",
            delay: index * 0.0001 // 스태거드 애니메이션
          }}
          whileHover={{ 
            scale: 1.5, 
            opacity: 1,
            transition: { duration: 0.2 }
          }}
          onMouseEnter={() => onHover(emotion)}
          onMouseLeave={() => onHover(null)}
          className="cursor-pointer"
        />
      ))}
    </g>
  );
}
```

### 8. 툴팁 컴포넌트

#### 8.1 EmotionTooltip.tsx

```typescript
'use client';

import { motion } from 'framer-motion';
import { EmotionPoint } from '@/lib/types/emotion';

interface EmotionTooltipProps {
  point: EmotionPoint;
  position: { x: number; y: number };
}

export function EmotionTooltip({ point, position }: EmotionTooltipProps) {
  const getStrategyColor = (strategy: string) => {
    switch (strategy) {
      case 'both_weighted': return 'bg-blue-100 text-blue-800';
      case 'warriner_only': return 'bg-green-100 text-green-800';
      case 'nrc_only': return 'bg-orange-100 text-orange-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 0.8) return 'text-green-600';
    if (confidence >= 0.7) return 'text-orange-600';
    return 'text-red-600';
  };

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{ duration: 0.2 }}
      className="absolute z-10 bg-white rounded-lg shadow-lg border p-4 max-w-xs"
      style={{
        left: position.x + 10,
        top: position.y - 10,
        transform: 'translateY(-100%)'
      }}
    >
      {/* 단어 정보 */}
      <div className="mb-3">
        <h3 className="font-bold text-lg text-gray-900">
          {point.term}
        </h3>
        {point.is_multiword && (
          <span className="text-xs text-gray-500">(다중어 표현)</span>
        )}
      </div>

      {/* V-A 좌표 */}
      <div className="grid grid-cols-2 gap-4 mb-3">
        <div>
          <div className="text-sm text-gray-600">Valence</div>
          <div className="font-semibold text-blue-600">
            {point.valence.toFixed(3)}
          </div>
        </div>
        <div>
          <div className="text-sm text-gray-600">Arousal</div>
          <div className="font-semibold text-red-600">
            {point.arousal.toFixed(3)}
          </div>
        </div>
      </div>

      {/* 병합 전략 */}
      <div className="mb-3">
        <div className="text-sm text-gray-600 mb-1">병합 전략</div>
        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStrategyColor(point.merge_strategy)}`}>
          {point.merge_strategy}
        </span>
      </div>

      {/* 신뢰도 */}
      <div>
        <div className="text-sm text-gray-600 mb-1">신뢰도</div>
        <div className="flex items-center gap-2">
          <div className="flex-1 bg-gray-200 rounded-full h-2">
            <div 
              className="bg-blue-500 h-2 rounded-full transition-all duration-300"
              style={{ width: `${point.confidence * 100}%` }}
            />
          </div>
          <span className={`text-sm font-medium ${getConfidenceColor(point.confidence)}`}>
            {(point.confidence * 100).toFixed(1)}%
          </span>
        </div>
      </div>
    </motion.div>
  );
}
```

### 9. 감정 프로토타입 컴포넌트

#### 9.1 EmotionPrototypes.tsx

```typescript
'use client';

import { motion } from 'framer-motion';

const emotionPrototypes = [
  { name: 'Joy', valence: 0.80, arousal: 0.55, color: '#FFE082' },      // 파스텔 골드
  { name: 'Anger', valence: -0.70, arousal: 0.70, color: '#FFB3B3' },   // 파스텔 레드
  { name: 'Fear', valence: -0.75, arousal: 0.75, color: '#B3B3FF' },    // 파스텔 퍼플
  { name: 'Sadness', valence: -0.70, arousal: -0.30, color: '#B3D9FF' }, // 파스텔 블루
  { name: 'Surprise', valence: 0.00, arousal: 0.70, color: '#FFD9B3' },  // 파스텔 오렌지
  { name: 'Disgust', valence: -0.65, arousal: 0.35, color: '#D9B3FF' },  // 파스텔 바이올렛
  { name: 'Calm', valence: 0.40, arousal: -0.40, color: '#B3FFB3' },     // 파스텔 그린
  { name: 'Excitement', valence: 0.60, arousal: 0.80, color: '#FFB3E6' }, // 파스텔 핑크
];

export function EmotionPrototypes() {
  return (
    <g>
      {emotionPrototypes.map((emotion, index) => (
        <g key={emotion.name}>
          {/* 프로토타입 점 */}
          <motion.circle
            cx={emotion.valence}
            cy={emotion.arousal}
            r="8"
            fill={emotion.color}
            stroke="white"
            strokeWidth="2"
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ 
              duration: 0.5,
              delay: index * 0.1,
              ease: "easeOut"
            }}
            whileHover={{ 
              scale: 1.3,
              transition: { duration: 0.2 }
            }}
          />
          
          {/* 라벨 */}
          <motion.text
            x={emotion.valence}
            y={emotion.arousal - 15}
            textAnchor="middle"
            className="text-sm font-bold fill-gray-800"
            initial={{ opacity: 0, y: emotion.arousal - 5 }}
            animate={{ opacity: 1, y: emotion.arousal - 15 }}
            transition={{ 
              duration: 0.5,
              delay: index * 0.1 + 0.2
            }}
          >
            {emotion.name}
          </motion.text>
        </g>
      ))}
    </g>
  );
}
```

---

## 🚀 API 구현

### 10. 감정 데이터 API

#### 10.1 app/api/emotions/route.ts

```typescript
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';

export async function GET() {
  try {
    const dataPath = path.join(process.cwd(), 'public', 'data', 'merged_vad.json');
    const data = fs.readFileSync(dataPath, 'utf8');
    const emotions = JSON.parse(data);

    // 필요한 필드만 추출하여 응답 크기 최적화
    const optimizedEmotions = emotions.map((emotion: any) => ({
      term: emotion.term,
      valence: emotion.valence_mean,
      arousal: emotion.arousal_mean,
      confidence: emotion.confidence,
      merge_strategy: emotion.merge_strategy,
      is_multiword: emotion.is_multiword
    }));

    return NextResponse.json(optimizedEmotions);
  } catch (error) {
    console.error('Error loading emotions data:', error);
    return NextResponse.json(
      { error: 'Failed to load emotions data' },
      { status: 500 }
    );
  }
}
```

### 11. 검색 API

#### 11.1 app/api/search/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('q');

  if (!query) {
    return NextResponse.json({ error: 'Query parameter required' }, { status: 400 });
  }

  try {
    // 실제 구현에서는 데이터베이스나 인덱스 검색 사용
    const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/emotions`);
    const emotions = await response.json();

    const results = emotions
      .filter((emotion: any) => 
        emotion.term.toLowerCase().includes(query.toLowerCase())
      )
      .slice(0, 50); // 상위 50개 결과만 반환

    return NextResponse.json(results);
  } catch (error) {
    console.error('Search error:', error);
    return NextResponse.json(
      { error: 'Search failed' },
      { status: 500 }
    );
  }
}
```

---

## 📊 성능 최적화

### 12. 가상화 및 최적화 전략

#### 12.1 가상화된 렌더링

```typescript
// lib/utils/performance.ts
export class VirtualizedRenderer {
  private viewport: { x: number; y: number; width: number; height: number };
  private allPoints: EmotionPoint[];
  private visiblePoints: EmotionPoint[] = [];

  constructor(points: EmotionPoint[], viewport: any) {
    this.allPoints = points;
    this.viewport = viewport;
    this.updateVisiblePoints();
  }

  updateViewport(newViewport: any) {
    this.viewport = newViewport;
    this.updateVisiblePoints();
  }

  private updateVisiblePoints() {
    this.visiblePoints = this.allPoints.filter(point => 
      this.isPointInViewport(point)
    );
  }

  private isPointInViewport(point: EmotionPoint): boolean {
    return (
      point.valence >= this.viewport.x &&
      point.valence <= this.viewport.x + this.viewport.width &&
      point.arousal >= this.viewport.y &&
      point.arousal <= this.viewport.y + this.viewport.height
    );
  }

  getVisiblePoints(): EmotionPoint[] {
    return this.visiblePoints;
  }
}
```

#### 12.2 메모이제이션

```typescript
// lib/utils/visualization.ts
import { useMemo } from 'react';

export function useOptimizedEmotions(emotions: EmotionPoint[], searchTerm: string) {
  return useMemo(() => {
    if (!searchTerm) return emotions;
    
    const lowerSearchTerm = searchTerm.toLowerCase();
    return emotions.filter(emotion => 
      emotion.term.toLowerCase().includes(lowerSearchTerm)
    );
  }, [emotions, searchTerm]);
}

export function useColorMapping(emotions: EmotionPoint[]) {
  return useMemo(() => {
    const colorMap = new Map<string, string>();
    emotions.forEach(emotion => {
      const key = `${emotion.confidence}-${emotion.merge_strategy}`;
      if (!colorMap.has(key)) {
        colorMap.set(key, generateColor(emotion.confidence, emotion.merge_strategy));
      }
    });
    return colorMap;
  }, [emotions]);
}
```

---

## 🎯 구현 로드맵

### 13. 개발 단계

#### 13.1 1단계: 기본 구조 (1일)

- [ ] Next.js 14 프로젝트 초기화
- [ ] TypeScript 설정 및 타입 정의
- [ ] 기본 레이아웃 및 컴포넌트 구조
- [ ] 데이터 로딩 API 구현

#### 13.2 2단계: 핵심 시각화 (2일)

- [ ] V-A 평면 기본 렌더링
- [ ] 산점도 컴포넌트 구현
- [ ] 마우스 hover 툴팁 구현
- [ ] 기본 애니메이션 효과

#### 13.3 3단계: 고급 기능 (2일)

- [ ] 감정 프로토타입 표시
- [ ] 밀도 히트맵 구현
- [ ] 검색 기능 구현
- [ ] 성능 최적화 (가상화)

#### 13.4 4단계: 완성도 향상 (1일)

- [ ] 반응형 디자인 완성
- [ ] 접근성 개선
- [ ] 에러 처리 및 로딩 상태
- [ ] 최종 테스트 및 배포

---

## 📋 체크리스트

### 14. 완성 기준

#### 14.1 기능적 요구사항

- [x] V-A 2차원 평면 시각화
- [x] 54,893개 감정 어휘 표시
- [x] 마우스 hover 시 단어 정보 표시
- [x] 가벼운 애니메이션 효과
- [x] EasyNext 기반 구현

#### 14.2 성능 요구사항

- [ ] 초기 로딩 시간 < 3초
- [ ] 30fps 애니메이션 유지
- [ ] 메모리 사용량 < 100MB
- [ ] 반응형 디자인 (웹페이지만만)

#### 14.3 사용자 경험

- [ ] 직관적인 인터페이스
- [ ] 빠른 검색 기능
- [ ] 부드러운 상호작용
- [ ] 접근성 준수

---

## 🎨 디자인 가이드

### 15. UI/UX 원칙

#### 15.1 색상 팔레트 (파스텔 톤)

```css
/* Primary Colors - 파스텔 톤 */
--primary-blue: #B3D9FF;      /* 파스텔 블루 */
--primary-green: #B3FFB3;     /* 파스텔 그린 */
--primary-orange: #FFD9B3;    /* 파스텔 오렌지 */
--primary-red: #FFB3B3;       /* 파스텔 레드 */
--primary-yellow: #FFE082;    /* 파스텔 옐로우 */
--primary-purple: #D9B3FF;    /* 파스텔 퍼플 */
--primary-pink: #FFB3E6;      /* 파스텔 핑크 */

/* Neutral Colors */
--gray-50: #F9FAFB;
--gray-100: #F3F4F6;
--gray-200: #E5E7EB;
--gray-300: #D1D5DB;
--gray-400: #9CA3AF;
--gray-500: #6B7280;
--gray-600: #4B5563;
--gray-700: #374151;
--gray-800: #1F2937;
--gray-900: #111827;
```

#### 15.2 타이포그래피

```css
/* Font Stack */
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

/* Font Sizes */
--text-xs: 0.75rem;    /* 12px */
--text-sm: 0.875rem;   /* 14px */
--text-base: 1rem;     /* 16px */
--text-lg: 1.125rem;   /* 18px */
--text-xl: 1.25rem;    /* 20px */
--text-2xl: 1.5rem;    /* 24px */
--text-3xl: 1.875rem;  /* 30px */
```

#### 15.3 간격 시스템

```css
/* Spacing Scale */
--space-1: 0.25rem;   /* 4px */
--space-2: 0.5rem;    /* 8px */
--space-3: 0.75rem;   /* 12px */
--space-4: 1rem;      /* 16px */
--space-6: 1.5rem;    /* 24px */
--space-8: 2rem;      /* 32px */
--space-12: 3rem;     /* 48px */
--space-16: 4rem;     /* 64px */
```

---

## 🚀 배포 및 운영

### 16. 배포 전략

#### 16.1 Vercel 배포

```json
// vercel.json
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "outputDirectory": ".next",
  "installCommand": "npm install",
  "devCommand": "npm run dev",
  "env": {
    "NEXT_PUBLIC_BASE_URL": "https://va-emotion-space.vercel.app"
  }
}
```

#### 16.2 성능 모니터링

```typescript
// lib/analytics.ts
export function trackPerformance() {
  if (typeof window !== 'undefined') {
    // Web Vitals 추적
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(console.log);
      getFID(console.log);
      getFCP(console.log);
      getLCP(console.log);
      getTTFB(console.log);
    });
  }
}
```

---

**프로젝트 시작일**: 2025년 10월 2일  
**예상 완료일**: 2025년 10월 8일  
**담당자**: VEATIC 연구팀  
**버전**: v1.0
